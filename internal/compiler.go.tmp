package main

import (
	"bytes"
	"compress/gzip"
	_ "embed"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
)

//go:embed node.gz
var nodeBinaryCompressed []byte

//go:embed bundled.js
var jsapp []byte

func cleanupNode(tmpNodePath string) error {
	return os.Remove(tmpNodePath)
}

func main() {
	// inflate the gzip-compressed application
	nodeBinary, err := decompressGzip(nodeBinaryCompressed)

	// Write the embedded Node.js binary to a temporary file
	tmpNodePath, err := writeTempFile(nodeBinary, "node")
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to write temporary node binary: %v\n", err)
		os.Exit(1)
	}

	// Get command line arguments, excluding the name of the program itself
	args := os.Args[1:]

	// Create a command with the arguments
	cmd := exec.Command(tmpNodePath, args...)

	// Set up the pipes
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// always destroy the node.js stuffs when we're done with it
	defer cleanupNode(tmpNodePath)

	// Start the command
	err = cmd.Start()
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to start node: %v\n", err)
		os.Exit(1)
	}

	// Wait for the command to finish
	err = cmd.Wait()
	if err != nil {
		fmt.Fprintf(os.Stderr, "node exited with error: %v\n", err)
		os.Exit(1)
	}
}

func writeTempFile(data []byte, prefix string) (string, error) {
	tmpFileDir := path.Join(os.TempDir(), "nodec", "extracted")
	err := os.MkdirAll(tmpFileDir, 0755)

	if err != nil {
		return "", err
	}

	tmpFilePath := path.Join(tmpFileDir, "node")

	tmpFile, err := os.Create(tmpFilePath)
	if err != nil {
		return "", err
	}

	_, err = io.Copy(tmpFile, bytes.NewReader(data))
	if err != nil {
		return "", err
	}

	err = tmpFile.Close()
	if err != nil {
		return "", err
	}

	err = os.Chmod(tmpFile.Name(), 0755)
	if err != nil {
		return "", err
	}

	return tmpFile.Name(), nil
}

func decompressGzip(data []byte) ([]byte, error) {
	reader, err := gzip.NewReader(bytes.NewReader(data))
	if err != nil {
		return nil, err
	}
	defer reader.Close()

	buf := new(bytes.Buffer)
	if _, err := io.Copy(buf, reader); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
